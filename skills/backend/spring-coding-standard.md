---
name: spring-backend-architecture-and-standards
description: "Spring backend architecture and coding standards focused on design decision criteria: minimal structure, strict state control, enum-first state modeling, readability-first implementation, progressive refactoring, and predictable system boundaries."
---

# Spring Backend Architecture & Coding Standards

Spring 기반 서버 개발에서 “어떻게”보다 “왜 그렇게 설계하는가”에 초점을 둔 판단 기준 문서.

---

## Core Philosophy

- 구조는 최소 단위로 시작하고, 필요할 때만 확장한다.
- 상태는 캡슐화하고, 외부에서 직접 변경되지 않도록 통제한다.
- boolean이 늘어날 조짐이 보이면 enum(또는 상태 객체) 통합을 우선 고려한다.
- 최적화보다 가독성과 예측 가능성이 우선이다.
- 리팩토링은 상시 수행이 아니라, 필요성이 체감되는 시점에 진행한다(큰 변경은 먼저 합의).
- “패턴을 쓰기 위해 패턴을 쓰지 않는다.” 문제를 해결하는 최소 설계를 선호한다.

---

## Project Structure Policy

### 설계 기준

- 패키지 depth는 얕게 유지한다.
- 레이어는 최소로 두고, 책임이 명확해질 때만 분리한다.
- 공통 유틸/헬퍼가 무분별하게 커지는 구조를 지양한다.

### 권장 구조(의도 중심)

- `api` (Controller, Request/Response DTO)
- `application` (UseCase/Service: 유스케이스 단위)
- `domain` (도메인 모델/정책/도메인 서비스)
- `infra` (Repository 구현, 외부 시스템 연동, 메시징, 캐시, 클라이언트)

### 판단 질문

- 이 분리는 “실제 변경 분리”를 만들어내는가?
- 패키지/레이어 추가로 이해 비용이 증가하지 않는가?

---

## Encapsulation & Mutability Policy

### 기본 원칙

- 모든 필드는 private.
- 외부 읽기/수정은 Getter/Setter 또는 명시적 메서드를 통해서만.
- 무분별한 Setter 제공 금지(상태 무결성 필요 시 메서드 기반 변경 우선).

### 판단 기준

- 이 값은 “외부에서 바뀌어도 되는가?”
- 변경이 비즈니스 규칙을 깨뜨릴 가능성이 있는가?

---

## Boolean → Enum Strategy

### 기본 원칙

- boolean 플래그가 늘어나기 시작하면 enum/상태 모델로 통합을 우선 검토한다.
- 단, “지금 당장”이 아니라 “정말 상태가 늘어나는지” 확인 후 적용한다.

### 판단 질문

- 이 상태는 상호 배타적인가?
- 상태 조합이 의미를 가지기 시작했는가?
- 플래그 증가가 버그 가능성을 높이고 있는가?

---

## Dependency Injection Policy

### 기본 원칙

- 생성자 주입을 기본으로 한다.
- Field Injection 지양(테스트/가시성/불변성 측면).
- “전역 접근”처럼 보이는 구조(무분별한 static util, Service Locator)는 지양한다.
- Spring Bean은 기본적으로 Singleton이므로, 싱글톤 패턴을 코드로 구현하기보다 컨테이너를 활용한다.

### 판단 기준

- 의존성 그래프가 설명 가능한가?
- 테스트에서 대체 가능한가?

---

## Controller Policy

### 설계 기준

- Controller는 얇게 유지한다.
- 인증/인가, 파라미터 검증, 요청/응답 매핑까지만 담당한다.
- 비즈니스 로직은 application/service(usecase)로 위임한다.

### 판단 질문

- 이 로직은 “HTTP가 아니어도” 존재해야 하는가?
- 재사용/테스트가 필요한 로직인가?

---

## Service / UseCase Policy

### 설계 기준

- Service는 “유스케이스 단위”로 작성한다.
- 한 메서드는 하나의 의도를 가진 흐름을 표현해야 한다.
- 흐름은 직선적(early return/guard clause)으로 유지한다.
- 과도한 추상화(인터페이스 쪼개기, 템플릿 패턴 남용) 지양.

### 판단 기준

- 이 메서드는 한 줄로 설명 가능한가?
- 분기가 많아졌다면 상태/전략 분리가 필요한 시점인가?

---

## Repository & Persistence Policy

### 설계 기준

- Repository는 데이터 접근 책임만 가진다.
- 비즈니스 규칙을 Repository로 밀어 넣지 않는다.
- 조회 전용/명령 전용(CQRS)을 “필요할 때만” 고려한다.

### 판단 질문

- 이 로직은 DB가 바뀌면 함께 바뀌는가?
- 도메인 규칙인가, 저장소 최적화인가?

---

## Transaction Policy

### 기본 원칙

- 트랜잭션 경계는 “유스케이스(Service)”에 둔다.
- 트랜잭션은 가능한 짧게 유지한다.
- 네트워크 호출/외부 I/O를 트랜잭션 내부에 무분별하게 넣지 않는다.

### 판단 질문

- 원자성이 필요한 범위가 어디까지인가?
- 실패 시 롤백이 필요한 데이터는 무엇인가?

---

## Validation Policy

### 설계 기준

- 입력 검증은 API 경계(Controller/DTO)에서 1차 수행한다.
- 도메인 규칙은 도메인(또는 유스케이스)에서 최종적으로 보장한다.
- “검증 로직이 분산”되지 않도록 책임을 명확히 한다.

### 판단 기준

- 이 검증은 “형식 검증”인가 “비즈니스 규칙”인가?

---

## Error Handling Policy

### 기본 원칙

- 예외는 의미 있는 도메인/유스케이스 단위로 정의한다.
- 에러 응답은 일관된 포맷을 유지한다.
- 예외 메시지는 내부 디버깅에 유용해야 하고, 외부 노출 정보는 제한한다.

### 판단 기준

- 이 실패는 “정상 흐름의 일부”인가, “버그/장애”인가?
- 호출자가 복구 가능한가?

---

## Logging & Observability Policy

### 설계 기준

- 요청 단위 추적이 가능해야 한다(요청 ID/트레이싱).
- 에러 로그는 원인 파악 가능해야 한다(컨텍스트 포함).
- 민감 정보(토큰/개인정보)는 로그에 남기지 않는다.
- “로그가 설계를 대체하지 않게” 한다(로직을 로그로 추적해야 하는 구조는 지양).

---

## Async / Event Policy

### 설계 기준

- 동기 흐름이 단순하면 동기를 유지한다.
- 비동기/이벤트는 “병목/결합도” 문제가 명확할 때만 도입한다.
- 이벤트 기반 처리는 추적/재시도/중복 처리 전략이 동반되어야 한다.

### 판단 질문

- 비동기가 진짜로 필요한가, 아니면 현재 설계가 복잡한가?
- 실패/중복/순서 문제를 어떻게 다룰 것인가?

---

## Performance Policy

### 기본 원칙

- 측정 없이 최적화하지 않는다.
- DB/캐시/인덱스/쿼리 최적화는 병목이 확인된 후 수행한다.
- 단순한 구현을 우선하고, 필요 시 단계적으로 최적화한다.

### 판단 기준

- 병목 지점이 어디인지 설명 가능한가?
- 최적화로 유지보수 비용이 과도하게 증가하지 않는가?

---

## Security Boundary Policy

### 설계 기준

- 인증/인가는 경계에서 처리하고, 내부 로직은 신뢰 가능한 전제로 단순화한다.
- 입력은 신뢰하지 않는다(검증/정규화).
- 민감 데이터의 보관/전달/로그 정책을 명확히 한다.

---

## Progressive Refactoring Rule

### 기본 원칙

- 리팩토링은 “항상”이 아니라 “필요성 체감” 시점에 한다.
- 큰 구조 변경은 먼저 합의하고 진행한다.
- 전면 재작성보다 점진적 개선을 우선한다.

---

## Change Strategy Checklist

기능 추가/변경 시 스스로에게 묻는다:

1. 지금 구조를 더 복잡하게 만들지 않고 해결 가능한가?
2. 상태가 외부에서 직접 변경될 여지가 생기지 않았는가?
3. boolean이 늘어나고 있지 않은가? enum/상태 모델이 더 적절한가?
4. 트랜잭션 경계가 유스케이스에 맞게 설정되어 있는가?
5. Controller가 비즈니스 로직을 갖고 있지 않은가?
6. Repository가 도메인 규칙을 떠안고 있지 않은가?
7. 비동기/이벤트 도입이 “필요성”에 의해 결정되었는가?
8. 관측 가능성(로그/추적)과 보안(민감정보)이 유지되는가?
9. 리팩토링이 필요하다면, 범위/리스크를 먼저 합의했는가?

---

## One-Line Philosophy

예측 가능한 시스템을 구축한다.  
구조는 최소로 시작한다.  
상태는 통제한다.  
복잡성은 필요할 때만 증가시킨다.
